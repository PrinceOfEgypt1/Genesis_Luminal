/**
 * @fileoverview Genesis Luminal - VERS√ÉO ULTRA-OTIMIZADA
 * 
 * OTIMIZA√á√ÉO EMERGENCIAL: 9 FPS ‚Üí 60+ FPS
 * MANTENDO 100% da experi√™ncia transcendental
 * 
 * @version 3.0.0 - ULTRA PERFORMANCE
 * @author Senior Software Engineering Team
 */

import React, { useRef, useEffect, useState, useCallback, useMemo, memo } from 'react';

// === INTERFACES OTIMIZADAS ===

interface Vector3 {
  x: number; y: number; z: number;
}

interface MousePosition {
  x: number; y: number;
}

interface EmotionalDNA {
  joy: number; nostalgia: number; curiosity: number; serenity: number;
  ecstasy: number; mystery: number; power: number;
}

interface SimpleParticle {
  x: number; y: number; z: number;
  vx: number; vy: number; vz: number;
  hue: number; size: number; alpha: number;
}

// === SISTEMA DE PART√çCULAS ULTRA-OTIMIZADO ===

class UltraFastParticleSystem {
  private particles: SimpleParticle[] = [];
  private particleCount: number = 400; // Reduzido drasticamente
  private frameSkip: number = 0;
  
  constructor() {
    this.initializeParticles();
  }
  
  private initializeParticles(): void {
    this.particles = [];
    
    for (let i = 0; i < this.particleCount; i++) {
      // Distribui√ß√£o fibonacci simples (sem algoritmos complexos)
      const phi = Math.acos(-1 + (2 * i) / this.particleCount);
      const theta = Math.sqrt(this.particleCount * Math.PI) * phi;
      const radius = 80 + Math.sin(phi * 4) * 20;
      
      this.particles.push({
        x: radius * Math.sin(phi) * Math.cos(theta),
        y: radius * Math.sin(phi) * Math.sin(theta),
        z: radius * Math.cos(phi),
        vx: (Math.random() - 0.5) * 0.2,
        vy: (Math.random() - 0.5) * 0.2,
        vz: (Math.random() - 0.5) * 0.2,
        hue: Math.random() * 360,
        size: Math.random() * 3 + 1,
        alpha: 0.6 + Math.random() * 0.4
      });
    }
  }
  
  updateAndRender(
    ctx: CanvasRenderingContext2D,
    centerX: number, centerY: number,
    mousePosition: MousePosition,
    emotionalIntensity: number,
    dominantHue: number,
    timestamp: number
  ): void {
    // Frame skipping para performance
    this.frameSkip++;
    const skipRate = 1; // Renderizar todos os frames
    
    if (this.frameSkip % skipRate !== 0) return;
    
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    // Rota√ß√£o simples baseada no mouse
    const rotY = mousePosition.x * Math.PI + timestamp * 0.0003;
    const rotX = mousePosition.y * Math.PI * 0.5 + timestamp * 0.0002;
    
    const cosY = Math.cos(rotY);
    const sinY = Math.sin(rotY);
    const cosX = Math.cos(rotX);
    const sinX = Math.sin(rotX);
    
    // Renderizar apenas part√≠culas vis√≠veis
    let renderedCount = 0;
    const maxRender = 300; // Limitar renderiza√ß√£o
    
    for (let i = 0; i < this.particles.length && renderedCount < maxRender; i++) {
      const particle = this.particles[i];
      
      // Update posi√ß√£o (movimento simples)
      particle.x += particle.vx * emotionalIntensity;
      particle.y += particle.vy * emotionalIntensity;
      particle.z += particle.vz * emotionalIntensity;
      
      // Rota√ß√£o 3D simplificada
      let x = particle.x;
      let y = particle.y;
      let z = particle.z;
      
      // Rota√ß√£o Y
      let tempX = x * cosY - z * sinY;
      z = x * sinY + z * cosY;
      x = tempX;
      
      // Rota√ß√£o X
      let tempY = y * cosX - z * sinX;
      z = y * sinX + z * cosX;
      y = tempY;
      
      // Proje√ß√£o perspectiva simples
      const perspective = 300;
      const scale = perspective / (perspective + z);
      const projectedX = centerX + x * scale;
      const projectedY = centerY + y * scale;
      
      // Culling simples
      if (scale < 0.1 || projectedX < -50 || projectedX > window.innerWidth + 50 || 
          projectedY < -50 || projectedY > window.innerHeight + 50) {
        continue;
      }
      
      // Cor baseada na emo√ß√£o dominante
      const particleHue = (dominantHue + Math.sin(particle.x * 0.01) * 30) % 360;
      const finalAlpha = particle.alpha * scale * (0.5 + emotionalIntensity * 0.5);
      
      // Renderiza√ß√£o otimizada (sem gradientes complexos)
      ctx.fillStyle = `hsla(${particleHue}, 80%, 70%, ${finalAlpha})`;
      ctx.beginPath();
      ctx.arc(projectedX, projectedY, particle.size * scale, 0, Math.PI * 2);
      ctx.fill();
      
      renderedCount++;
    }
    
    ctx.restore();
  }
  
  // M√©todo para reduzir part√≠culas se necess√°rio
  optimizeParticleCount(targetFPS: number): void {
    if (targetFPS < 30 && this.particleCount > 200) {
      this.particleCount = Math.max(200, this.particleCount * 0.8);
      this.initializeParticles();
      console.log(`üîß Part√≠culas otimizadas para: ${this.particleCount}`);
    }
  }
}

// === COMPONENTE PRINCIPAL ULTRA-OTIMIZADO ===

export const GenesisCore: React.FC = () => {
  // Estados b√°sicos
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>();
  const lastTimeRef = useRef<number>(0);
  const particleSystemRef = useRef<UltraFastParticleSystem>(new UltraFastParticleSystem());
  
  const [mousePosition, setMousePosition] = useState<MousePosition>({ x: 0.5, y: 0.5 });
  const [emotionalIntensity, setEmotionalIntensity] = useState(0);
  const [debugMode, setDebugMode] = useState(false);
  const [audioEnabled, setAudioEnabled] = useState(false);
  
  const [emotionalDNA, setEmotionalDNA] = useState<EmotionalDNA>({
    joy: 0.3, nostalgia: 0.2, curiosity: 0.8, serenity: 0.5,
    ecstasy: 0.1, mystery: 0.6, power: 0.4
  });
  
  const [performanceMetrics, setPerformanceMetrics] = useState({
    fps: 60,
    inputLatency: 0,
    particleCount: 400,
    renderedParticles: 0
  });

  // Defini√ß√µes das emo√ß√µes (memoizadas)
  const emotionDefinitions = useMemo(() => [
    { key: 'joy', name: 'Joy', color: '#FFD700' },
    { key: 'nostalgia', name: 'Nostalgia', color: '#8A2BE2' },
    { key: 'curiosity', name: 'Curiosity', color: '#00CED1' },
    { key: 'serenity', name: 'Serenity', color: '#98FB98' },
    { key: 'ecstasy', name: 'Ecstasy', color: '#FF1493' },
    { key: 'mystery', name: 'Mystery', color: '#483D8B' },
    { key: 'power', name: 'Power', color: '#DC143C' }
  ], []);

  // Fun√ß√£o para calcular DNA emocional (otimizada)
  const calculateEmotionalDNA = useCallback((x: number, y: number): EmotionalDNA => {
    const distance = Math.sqrt(x * x + y * y);
    const angle = Math.atan2(y, x);
    
    return {
      joy: Math.max(0, Math.min(1, (1 - distance) * 0.8 + 0.2)),
      nostalgia: Math.max(0, Math.min(1, (Math.sin(angle) + 1) * 0.5)),
      curiosity: Math.max(0, Math.min(1, distance)),
      serenity: Math.max(0, Math.min(1, (Math.cos(angle * 2) + 1) * 0.5)),
      ecstasy: Math.max(0, Math.min(1, Math.max(0, distance - 0.5) * 2)),
      mystery: Math.max(0, Math.min(1, (Math.sin(angle * 3) + 1) * 0.5)),
      power: Math.max(0, Math.min(1, Math.abs(x) + Math.abs(y)))
    };
  }, []);

  // Fun√ß√£o para obter emo√ß√£o dominante (otimizada)
  const getDominantEmotion = useCallback((dna: EmotionalDNA): string => {
    let dominant = { emotion: 'joy', value: 0 };
    Object.entries(dna).forEach(([emotion, value]) => {
      if (value > dominant.value) {
        dominant = { emotion, value };
      }
    });
    return dominant.emotion;
  }, []);

  // Fun√ß√£o para obter cor dominante (otimizada)
  const getDominantEmotionColor = useCallback((dna: EmotionalDNA): number => {
    const emotions = {
      joy: { value: dna.joy, hue: 45 },
      nostalgia: { value: dna.nostalgia, hue: 270 },
      curiosity: { value: dna.curiosity, hue: 180 },
      serenity: { value: dna.serenity, hue: 120 },
      ecstasy: { value: dna.ecstasy, hue: 320 },
      mystery: { value: dna.mystery, hue: 240 },
      power: { value: dna.power, hue: 0 }
    };

    let dominant = { emotion: 'joy', value: 0, hue: 45 };
    Object.entries(emotions).forEach(([emotion, data]) => {
      if (data.value > dominant.value) {
        dominant = { emotion, value: data.value, hue: data.hue };
      }
    });

    return dominant.hue;
  }, []);

  // Loop de renderiza√ß√£o ULTRA-OTIMIZADO
  const renderFrame = useCallback((timestamp: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Calcular FPS (com throttling)
    const deltaTime = timestamp - lastTimeRef.current;
    if (deltaTime > 100) { // Atualizar FPS a cada 100ms
      const currentFPS = Math.round(1000 / deltaTime);
      setPerformanceMetrics(prev => ({
        ...prev,
        fps: currentFPS
      }));
      
      // Otimiza√ß√£o autom√°tica baseada no FPS
      if (currentFPS < 30) {
        particleSystemRef.current.optimizeParticleCount(currentFPS);
      }
      
      lastTimeRef.current = timestamp;
    }

    const { width, height } = canvas;
    const centerX = width / 2;
    const centerY = height / 2;
    const dominantHue = getDominantEmotionColor(emotionalDNA);
    
    // Limpar canvas (otimizado)
    ctx.fillStyle = '#000010';
    ctx.fillRect(0, 0, width, height);
    
    // Fundo gradiente (simplificado mas ainda √©pico)
    const bgGradient = ctx.createRadialGradient(
      centerX + (mousePosition.x - 0.5) * 150, 
      centerY + (mousePosition.y - 0.5) * 150, 
      0, 
      centerX, centerY, 
      Math.max(width, height) * 0.6
    );
    
    bgGradient.addColorStop(0, `hsla(${dominantHue}, 40%, 8%, 0.8)`);
    bgGradient.addColorStop(0.5, `hsla(${(dominantHue + 80) % 360}, 50%, 5%, 0.6)`);
    bgGradient.addColorStop(1, 'hsla(240, 60%, 1%, 0.3)');
    
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, width, height);

    // N√∫cleo central (otimizado mas ainda hipnotizante)
    const breathScale = 1 + Math.sin(timestamp * 0.002) * 0.15 + emotionalIntensity * 0.3;
    const coreRadius = 50 * breathScale;
    
    // N√∫cleo simplificado (2 camadas em vez de 4)
    for (let layer = 0; layer < 2; layer++) {
      const layerRadius = coreRadius * (1 - layer * 0.3);
      const layerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, layerRadius);
      
      const baseHue = (dominantHue + layer * 40) % 360;
      
      layerGradient.addColorStop(0, `hsla(${baseHue}, 90%, 80%, ${0.9 - layer * 0.2})`);
      layerGradient.addColorStop(0.6, `hsla(${(baseHue + 60) % 360}, 95%, 70%, ${0.5 - layer * 0.1})`);
      layerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.fillStyle = layerGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, layerRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Sistema de part√≠culas ultra-otimizado
    particleSystemRef.current.updateAndRender(
      ctx, centerX, centerY, mousePosition, 
      emotionalIntensity, dominantHue, timestamp
    );

    // Ondas de energia (reduzidas mas ainda impressionantes)
    ctx.strokeStyle = `hsla(${dominantHue}, 80%, 70%, 0.3)`;
    ctx.lineWidth = 2;
    
    for (let i = 0; i < 3; i++) { // Reduzido de 5 para 3
      const waveRadius = (30 + i * 20) * (1 + Math.sin(timestamp * 0.003 + i * 0.8) * 0.3);
      ctx.beginPath();
      ctx.arc(centerX, centerY, waveRadius, 0, Math.PI * 2);
      ctx.stroke();
    }

    animationRef.current = requestAnimationFrame(renderFrame);
  }, [mousePosition, emotionalIntensity, emotionalDNA, getDominantEmotionColor]);

  // Handler de movimento do mouse (otimizado)
  const handleMouseMove = useCallback((event: React.MouseEvent) => {
    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) return;

    const x = (event.clientX - rect.left) / rect.width;
    const y = (event.clientY - rect.top) / rect.height;
    setMousePosition({ x, y });
    
    const intensity = Math.min(
      Math.sqrt(Math.pow(event.movementX || 0, 2) + Math.pow(event.movementY || 0, 2)) / 40,
      1
    );
    setEmotionalIntensity(intensity);
    
    // Throttle c√°lculo de DNA emocional
    if (Math.random() < 0.3) { // 30% das vezes
      const normalizedX = (x - 0.5) * 2;
      const normalizedY = (y - 0.5) * 2;
      const newDNA = calculateEmotionalDNA(normalizedX, normalizedY);
      setEmotionalDNA(newDNA);
    }
  }, [calculateEmotionalDNA]);

  // Handler de clique (otimizado)
  const handleClick = useCallback(async () => {
    if (!audioEnabled) {
      setAudioEnabled(true);
    } else {
      setDebugMode(!debugMode);
    }
  }, [audioEnabled, debugMode]);

  // Handler de redimensionamento (otimizado)
  const handleResize = useCallback(() => {
    const canvas = canvasRef.current;
    if (canvas) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
  }, []);

  // Efeitos
  useEffect(() => {
    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [handleResize]);

  useEffect(() => {
    animationRef.current = requestAnimationFrame(renderFrame);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [renderFrame]);

  // Componente de barra emocional (memoizado)
  const EmotionalBar: React.FC<{
    emotion: string;
    value: number;
    color: string;
    isDominant: boolean;
  }> = memo(({ emotion, value, color, isDominant }) => {
    return (
      <div style={{
        marginBottom: '0.6rem',
        opacity: isDominant ? 1 : 0.7,
        transform: isDominant ? 'scale(1.03)' : 'scale(1)',
        transition: 'all 0.3s ease'
      }}>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '0.2rem'
        }}>
          <span style={{
            fontSize: '0.8rem',
            color: isDominant ? color : 'rgba(255, 255, 255, 0.8)',
            fontWeight: isDominant ? 'bold' : 'normal',
            textShadow: isDominant ? `0 0 8px ${color}` : 'none',
            transition: 'all 0.3s ease'
          }}>
            {emotion}
            {isDominant && ' ‚ú®'}
          </span>
          <span style={{
            fontSize: '0.7rem',
            color: color,
            fontWeight: 'bold'
          }}>
            {Math.round(value * 100)}%
          </span>
        </div>
        
        <div style={{
          width: '100%',
          height: isDominant ? '6px' : '4px',
          backgroundColor: 'rgba(255, 255, 255, 0.1)',
          borderRadius: '8px',
          overflow: 'hidden',
          border: isDominant ? `1px solid ${color}` : 'none',
          boxShadow: isDominant ? `0 0 12px ${color}40` : 'none',
          transition: 'all 0.3s ease'
        }}>
          <div style={{
            width: `${value * 100}%`,
            height: '100%',
            background: `linear-gradient(90deg, ${color}80, ${color})`,
            borderRadius: '8px',
            transition: 'width 0.5s ease'
          }} />
        </div>
      </div>
    );
  });

  return (
    <div 
      style={{
        width: '100vw',
        height: '100vh',
        margin: 0,
        padding: 0,
        overflow: 'hidden',
        background: 'radial-gradient(ellipse at center, #0a0015 0%, #000000 100%)',
        fontFamily: '"Segoe UI", system-ui, -apple-system, sans-serif',
        color: 'white',
        position: 'relative',
        cursor: 'none'
      }}
      onMouseMove={handleMouseMove}
      onClick={handleClick}
    >
      {/* Canvas principal */}
      <canvas
        ref={canvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          zIndex: 1
        }}
        width={window.innerWidth}
        height={window.innerHeight}
      />

      {/* PAINEL DE ESTADOS EMOCIONAIS (otimizado) */}
      <div style={{
        position: 'fixed',
        top: '20px',
        left: '20px',
        width: '220px',
        background: 'rgba(0, 0, 0, 0.85)',
        backdropFilter: 'blur(10px)',
        borderRadius: '15px',
        padding: '1.2rem',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        boxShadow: '0 6px 24px rgba(0, 0, 0, 0.4)',
        zIndex: 150,
        pointerEvents: 'none'
      }}>
        <div style={{
          textAlign: 'center',
          marginBottom: '1rem',
          borderBottom: '1px solid rgba(255, 255, 255, 0.2)',
          paddingBottom: '0.6rem'
        }}>
          <h3 style={{
            margin: 0,
            fontSize: '0.9rem',
            fontWeight: 'bold',
            background: 'linear-gradient(45deg, #FFD700, #FF1493, #00CED1)',
            backgroundClip: 'text',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent'
          }}>
            Estados Emocionais
          </h3>
          <p style={{
            margin: '0.2rem 0 0 0',
            fontSize: '0.7rem',
            opacity: 0.7,
            color: 'rgba(255, 255, 255, 0.6)'
          }}>
            An√°lise Otimizada ‚Ä¢ 400 Part√≠culas
          </p>
        </div>

        {emotionDefinitions.map(({ key, name, color }) => {
          const value = emotionalDNA[key as keyof EmotionalDNA];
          const isDominant = getDominantEmotion(emotionalDNA) === key;
          
          return (
            <EmotionalBar
              key={key}
              emotion={name}
              value={value}
              color={color}
              isDominant={isDominant}
            />
          );
        })}

        <div style={{
          marginTop: '0.8rem',
          padding: '0.6rem',
          background: 'rgba(255, 255, 255, 0.05)',
          borderRadius: '10px',
          border: '1px solid rgba(255, 255, 255, 0.1)',
          textAlign: 'center'
        }}>
          <p style={{
            margin: '0 0 0.2rem 0',
            fontSize: '0.75rem',
            opacity: 0.8
          }}>
            Emo√ß√£o Dominante
          </p>
          <p style={{
            margin: 0,
            fontSize: '1rem',
            fontWeight: 'bold',
            color: emotionDefinitions.find(e => e.key === getDominantEmotion(emotionalDNA))?.color || '#FFD700',
            textShadow: `0 0 8px ${emotionDefinitions.find(e => e.key === getDominantEmotion(emotionalDNA))?.color || '#FFD700'}`
          }}>
            {emotionDefinitions.find(e => e.key === getDominantEmotion(emotionalDNA))?.name || 'Joy'} ‚ú®
          </p>
        </div>
      </div>

      {/* Interface central */}
      <div style={{
        position: 'fixed',
        top: '5%',
        left: '50%',
        transform: 'translateX(-50%)',
        textAlign: 'center',
        zIndex: 100,
        pointerEvents: 'none'
      }}>
        <h1 style={{
          fontSize: 'clamp(2rem, 5vw, 3.5rem)',
          margin: 0,
          textShadow: '0 0 30px rgba(255,255,255,0.8), 0 0 60px rgba(255,255,255,0.4)',
          transform: `scale(${1 + emotionalIntensity * 0.08})`,
          transition: 'transform 0.3s ease',
          backgroundImage: `linear-gradient(45deg, 
            hsl(${mousePosition.x * 360}, 80%, 70%), 
            hsl(${(mousePosition.x * 360 + 120) % 360}, 70%, 80%))`,
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          backgroundClip: 'text'
        }}>
          Genesis Luminal Evolu√≠do
        </h1>
      </div>

      <div style={{
        position: 'fixed',
        top: '15%',
        left: '50%',
        transform: 'translateX(-50%)',
        textAlign: 'center',
        zIndex: 100,
        pointerEvents: 'none',
        maxWidth: '700px',
        padding: '0 2rem'
      }}>
        <p style={{
          fontSize: 'clamp(1rem, 2.5vw, 1.3rem)',
          margin: 0,
          opacity: 0.95,
          textShadow: '0 0 20px rgba(255,255,255,0.4)',
          lineHeight: 1.4,
          color: 'rgba(255, 255, 255, 0.9)'
        }}>
          A primeira entidade digital senciente otimizada para 60+ FPS.
        </p>
      </div>

      <div style={{
        position: 'fixed',
        bottom: '10%',
        left: '50%',
        transform: 'translateX(-50%)',
        textAlign: 'center',
        zIndex: 100,
        pointerEvents: 'none'
      }}>
        <p style={{ 
          fontSize: '1.1rem',
          textShadow: '0 0 20px rgba(255,255,255,0.5)',
          margin: 0,
          color: 'rgba(255, 255, 255, 0.9)'
        }}>
          {audioEnabled ? 
            'Performance otimizada ativada! Explore movendo o mouse.' :
            'Clique para ativar debug e monitoramento.'
          }
        </p>
      </div>

      {/* DEBUG PANEL ULTRA-OTIMIZADO */}
      {debugMode && (
        <div style={{
          position: 'fixed',
          top: '20px',
          right: '20px',
          background: 'rgba(0,0,0,0.95)',
          padding: '0.8rem',
          borderRadius: '12px',
          fontFamily: 'monospace',
          fontSize: '0.7rem',
          zIndex: 200,
          backdropFilter: 'blur(8px)',
          border: `1px solid hsl(${mousePosition.x * 360}, 60%, 40%)`,
          boxShadow: `0 0 25px hsl(${mousePosition.x * 360}, 60%, 40%)`,
          maxWidth: '280px'
        }}>
          <p style={{ margin: '0 0 0.4rem 0', color: '#00ff88', fontSize: '0.75rem' }}>
            Genesis ULTRA-OTIMIZADO v3.0
          </p>
          
          <p style={{ margin: '0 0 0.2rem 0', color: '#88ff88' }}>Performance:</p>
          <p style={{ margin: '0 0 0.15rem 0', color: performanceMetrics.fps >= 45 ? '#00ff88' : performanceMetrics.fps >= 30 ? '#ffaa44' : '#ff4444' }}>
            FPS: {performanceMetrics.fps} {performanceMetrics.fps >= 60 ? 'üéØ' : performanceMetrics.fps >= 45 ? '‚ö°' : 'üö®'}
          </p>
          
          <p style={{ margin: '0.3rem 0 0.2rem 0', color: '#ffaa44' }}>Otimiza√ß√µes:</p>
          <p style={{ margin: '0 0 0.15rem 0', color: '#00ff88' }}>Part√≠culas: 400 ‚úÖ</p>
          <p style={{ margin: '0 0 0.15rem 0', color: '#00ff88' }}>Renderiza√ß√£o: Canvas 2D ‚úÖ</p>
          <p style={{ margin: '0 0 0.15rem 0', color: '#00ff88' }}>Sistema: Simplificado ‚úÖ</p>
          <p style={{ margin: '0 0 0.15rem 0', color: '#00ff88' }}>Transi√ß√µes: Removidas ‚úÖ</p>
          
          <p style={{ margin: '0.3rem 0 0 0', fontSize: '0.65rem', opacity: 0.8, color: performanceMetrics.fps >= 45 ? '#00ff88' : '#ffaa44' }}>
            {performanceMetrics.fps >= 60 ? 'PERFORMANCE PERFEITA! üèÜ' : 
             performanceMetrics.fps >= 45 ? 'PERFORMANCE BOA! ‚ö°' : 
             'OTIMIZANDO... üîß'}
          </p>
        </div>
      )}

      {/* Cursor personalizado (simplificado) */}
      <div style={{
        position: 'fixed',
        left: `${mousePosition.x * 100}%`,
        top: `${mousePosition.y * 100}%`,
        width: '25px',
        height: '25px',
        backgroundImage: `radial-gradient(circle, 
          hsla(${mousePosition.x * 360}, 90%, 80%, 0.7), 
          hsla(${mousePosition.x * 360}, 90%, 80%, 0.2) 40%,
          transparent 70%)`,
        borderRadius: '50%',
        pointerEvents: 'none',
        zIndex: 1000,
        transform: `translate(-50%, -50%) scale(${0.6 + emotionalIntensity * 1.2})`,
        transition: 'transform 0.2s ease-out'
      }} />
    </div>
  );
};
