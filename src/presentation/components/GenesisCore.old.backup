/**
 * @fileoverview Genesis Luminal Evolu√≠do - OTIMIZA√á√ÉO CR√çTICA DE PERFORMANCE
 * 
 * CORRE√á√ïES APLICADAS:
 * ‚úÖ WebGL 1.0 compatibility (removed instanced rendering)
 * ‚úÖ Fixed TypeScript errors
 * ‚úÖ Optimized particle rendering
 * ‚úÖ Adaptive performance system
 * 
 * @version 2.5.1 - WEBGL COMPATIBILITY FIX
 * @author Senior Software Engineering Team
 * @since 2024-09-08
 */

import React, { useRef, useEffect, useState, useCallback, memo } from 'react';

// === INTERFACES E TIPOS ===
interface OptimizedParticle {
  x: number; y: number; z: number;
  vx: number; vy: number; vz: number;
  life: number; maxLife: number;
  size: number; hue: number;
  visible: boolean; lastUpdate: number;
  lodLevel: number; quadrant: number;
  originalIndex: number;
  targetPosition: Vector3;
  transitionProgress: number;
}

interface Vector3 { x: number; y: number; z: number; }
interface MousePosition { x: number; y: number; }

// === SISTEMA WEBGL COMPAT√çVEL ===
class UltraFastWebGLRenderer {
  private gl: WebGLRenderingContext | null = null;
  private canvas: HTMLCanvasElement | null = null;
  private shaderProgram: WebGLProgram | null = null;
  private vertexBuffer: WebGLBuffer | null = null;
  private isEnabled: boolean = false;
    
  // Shaders otimizados para WebGL 1.0
  private vertexShaderSource = `
    attribute vec3 aPosition;
    attribute float aSize;
    attribute float aHue;
    
    uniform vec2 uMouse;
    uniform float uTime;
    uniform float uIntensity;
    uniform vec2 uResolution;
    uniform vec4 uRotation;
    
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
      vec3 pos = aPosition;
      
      // Rota√ß√£o otimizada
      float cosY = uRotation.x, sinY = uRotation.y;
      float cosX = uRotation.z, sinX = uRotation.w;
      
      // Aplicar rota√ß√£o Y
      float tempX = pos.x * cosY - pos.z * sinY;
      pos.z = pos.x * sinY + pos.z * cosY;
      pos.x = tempX;
      
      // Aplicar rota√ß√£o X
      float tempY = pos.y * cosX - pos.z * sinX;
      pos.z = pos.y * sinX + pos.z * cosX;
      pos.y = tempY;
      
      // Proje√ß√£o perspectiva simplificada
      float perspective = 400.0;
      float scale = perspective / (perspective + pos.z);
      
      vec2 clipPos = (pos.xy * scale) / (uResolution * 0.5);
      gl_Position = vec4(clipPos, pos.z * 0.001, 1.0);
      gl_PointSize = max(1.5, aSize * scale * (1.3 + uIntensity * 1.8));
      
      // Cores otimizadas
      float hue = aHue / 360.0;
      float saturation = 0.8;
      float lightness = 0.6;
      
      // Convers√£o HSL‚ÜíRGB otimizada
      float c = (1.0 - abs(2.0 * lightness - 1.0)) * saturation;
      float x = c * (1.0 - abs(mod(hue * 6.0, 2.0) - 1.0));
      float m = lightness - c / 2.0;
      
      if (hue < 1.0/6.0) {
        vColor = vec3(c + m, x + m, m);
      } else if (hue < 2.0/6.0) {
        vColor = vec3(x + m, c + m, m);
      } else if (hue < 3.0/6.0) {
        vColor = vec3(m, c + m, x + m);
      } else if (hue < 4.0/6.0) {
        vColor = vec3(m, x + m, c + m);
      } else if (hue < 5.0/6.0) {
        vColor = vec3(x + m, m, c + m);
      } else {
        vColor = vec3(c + m, m, x + m);
      }
      
      vAlpha = max(0.3, (300.0 + pos.z) / 600.0);
    }
  `;
  
  private fragmentShaderSource = `
    precision mediump float;
    
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
      vec2 center = gl_PointCoord - 0.5;
      float dist = length(center);
      
      if (dist > 0.5) discard;
      
      float glow = 1.0 - smoothstep(0.0, 0.5, dist);
      float coreGlow = 1.0 - smoothstep(0.0, 0.2, dist);
      
      vec3 finalColor = vColor * (0.7 + coreGlow * 1.3);
      float finalAlpha = vAlpha * glow;
      
      gl_FragColor = vec4(finalColor, finalAlpha);
    }
  `;

  initialize(canvas: HTMLCanvasElement): boolean {
    this.canvas = canvas;
    
    try {
      this.gl = canvas.getContext('webgl', {
        alpha: true,
        antialias: false,
        depth: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        powerPreference: 'high-performance'
      });
    } catch (error) {
      console.error('WebGL not supported:', error);
      return false;
    }
    
    if (!this.gl) return false;

    // Configura√ß√µes de performance
    this.gl.enable(this.gl.BLEND);
    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
    this.gl.disable(this.gl.DEPTH_TEST);
    this.gl.disable(this.gl.STENCIL_TEST);

    // Compilar shaders
    const vertexShader = this.compileShader(this.vertexShaderSource, this.gl.VERTEX_SHADER);
    const fragmentShader = this.compileShader(this.fragmentShaderSource, this.gl.FRAGMENT_SHADER);
    
    if (!vertexShader || !fragmentShader) return false;

    // Criar programa
    this.shaderProgram = this.gl.createProgram();
    if (!this.shaderProgram) return false;

    this.gl.attachShader(this.shaderProgram, vertexShader);
    this.gl.attachShader(this.shaderProgram, fragmentShader);
    this.gl.linkProgram(this.shaderProgram);

    if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
      console.error('Shader program link error:', this.gl.getProgramInfoLog(this.shaderProgram));
      return false;
    }

    // Criar buffer
    this.vertexBuffer = this.gl.createBuffer();
    
    this.isEnabled = true;
    console.log('üöÄ WebGL Renderer initialized (WebGL 1.0 compatible)');
    return true;
  }

  private compileShader(source: string, type: number): WebGLShader | null {
    if (!this.gl) return null;

    const shader = this.gl.createShader(type);
    if (!shader) return null;

    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
      this.gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  // Renderiza√ß√£o WebGL 1.0 compat√≠vel
  renderParticles(
    particles: OptimizedParticle[],
    mousePosition: MousePosition,
    emotionalIntensity: number,
    timestamp: number
  ): boolean {
    if (!this.gl || !this.shaderProgram || !this.vertexBuffer || !this.isEnabled) {
      return false;
    }

    const { width, height } = this.canvas!;
    this.gl.viewport(0, 0, width, height);
    this.gl.clearColor(0, 0, 0, 0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);

    if (particles.length === 0) {
      return false;
    }

    // Preparar dados das part√≠culas
    const particleData = new Float32Array(particles.length * 5);
    
    for (let i = 0; i < particles.length; i++) {
      const particle = particles[i];
      const baseIndex = i * 5;
      
      particleData[baseIndex] = particle.x;
      particleData[baseIndex + 1] = particle.y;
      particleData[baseIndex + 2] = particle.z;
      particleData[baseIndex + 3] = particle.size;
      particleData[baseIndex + 4] = particle.hue;
    }

    // Upload para GPU
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, particleData, this.gl.DYNAMIC_DRAW);
    
    // Usar programa
    this.gl.useProgram(this.shaderProgram);

    // Configurar atributos
    const positionAttrib = this.gl.getAttribLocation(this.shaderProgram, 'aPosition');
    const sizeAttrib = this.gl.getAttribLocation(this.shaderProgram, 'aSize');
    const hueAttrib = this.gl.getAttribLocation(this.shaderProgram, 'aHue');

    this.gl.enableVertexAttribArray(positionAttrib);
    this.gl.vertexAttribPointer(positionAttrib, 3, this.gl.FLOAT, false, 20, 0);
    
    this.gl.enableVertexAttribArray(sizeAttrib);
    this.gl.vertexAttribPointer(sizeAttrib, 1, this.gl.FLOAT, false, 20, 12);
    
    this.gl.enableVertexAttribArray(hueAttrib);
    this.gl.vertexAttribPointer(hueAttrib, 1, this.gl.FLOAT, false, 20, 16);

    // Configurar uniforms
    const rotY = mousePosition.x * Math.PI * 2 + timestamp * 0.0005;
    const rotX = mousePosition.y * Math.PI * 1.5 + timestamp * 0.0004;
    const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
    const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
    
    const mouseUniform = this.gl.getUniformLocation(this.shaderProgram, 'uMouse');
    const timeUniform = this.gl.getUniformLocation(this.shaderProgram, 'uTime');
    const intensityUniform = this.gl.getUniformLocation(this.shaderProgram, 'uIntensity');
    const resolutionUniform = this.gl.getUniformLocation(this.shaderProgram, 'uResolution');
    const rotationUniform = this.gl.getUniformLocation(this.shaderProgram, 'uRotation');

    if (mouseUniform) this.gl.uniform2f(mouseUniform, mousePosition.x, mousePosition.y);
    if (timeUniform) this.gl.uniform1f(timeUniform, timestamp * 0.001);
    if (intensityUniform) this.gl.uniform1f(intensityUniform, emotionalIntensity);
    if (resolutionUniform) this.gl.uniform2f(resolutionUniform, width, height);
    if (rotationUniform) this.gl.uniform4f(rotationUniform, cosY, sinY, cosX, sinX);

    // Renderizar part√≠culas
    this.gl.drawArrays(this.gl.POINTS, 0, particles.length);
    
    return true;
  }

  isWebGLEnabled(): boolean {
    return this.isEnabled;
  }

  cleanup(): void {
    if (this.gl) {
      if (this.shaderProgram) this.gl.deleteProgram(this.shaderProgram);
      if (this.vertexBuffer) this.gl.deleteBuffer(this.vertexBuffer);
    }
    this.isEnabled = false;
  }
}

// === SISTEMA DE PART√çCULAS OTIMIZADO ===
class OptimizedParticleSystem {
  private particles: OptimizedParticle[] = [];
  private visibleParticles: OptimizedParticle[] = [];
  private frameCount: number = 0;
  
  constructor(count: number = 800) {
    this.initializeParticles(count);
  }
  
  private initializeParticles(count: number): void {
    this.particles = new Array(count);
    
    for (let i = 0; i < count; i++) {
      // Distribui√ß√£o Fibonacci otimizada
      const phi = Math.acos(-1 + (2 * i) / count);
      const theta = Math.sqrt(count * Math.PI) * phi;
      const radius = 80 + Math.sin(phi * 6) * 30;
      
      this.particles[i] = {
        x: radius * Math.sin(phi) * Math.cos(theta),
        y: radius * Math.sin(phi) * Math.sin(theta),
        z: radius * Math.cos(phi),
        vx: (Math.random() - 0.5) * 0.2,
        vy: (Math.random() - 0.5) * 0.2,
        vz: (Math.random() - 0.5) * 0.2,
        hue: Math.random() * 360,
        size: Math.random() * 3 + 0.5,
        life: Math.random(),
        visible: true,
        lodLevel: 0,
        quadrant: 0,
        originalIndex: i,
        targetPosition: { x: 0, y: 0, z: 0 },
        transitionProgress: 1,
        maxLife: 1,
        lastUpdate: 0
      };
    }
  }
  
  /**
   * Update ultra-otimizado com adaptive frame skipping
   */
  updateParticles(
    intensity: number, 
    targetFPS: number = 60
  ): OptimizedParticle[] {
    this.frameCount++;
    
    // Skip frames baseado na performance
    const skipRate = this.getOptimalSkipRate(targetFPS);
    if (this.frameCount % skipRate !== 0) {
      return this.visibleParticles;
    }
    
    this.visibleParticles.length = 0;
    const maxVisible = this.getMaxVisibleParticles(targetFPS);
    
    for (let i = 0; i < this.particles.length && this.visibleParticles.length < maxVisible; i++) {
      const particle = this.particles[i];
      
      // Update otimizado apenas para part√≠culas vis√≠veis
      if (particle.visible) {
        // Movimento b√°sico
        particle.x += particle.vx * intensity;
        particle.y += particle.vy * intensity;
        particle.z += particle.vz * intensity;
        
        // Ciclo de vida
        particle.life += 0.01;
        if (particle.life > 1) {
          particle.life = 0;
          // Reset suave da posi√ß√£o
          const phi = Math.acos(-1 + (2 * i) / this.particles.length);
          const theta = Math.sqrt(this.particles.length * Math.PI) * phi;
          const radius = 80 + Math.sin(phi * 6) * 30;
          
          particle.x = radius * Math.sin(phi) * Math.cos(theta);
          particle.y = radius * Math.sin(phi) * Math.sin(theta);
          particle.z = radius * Math.cos(phi);
        }
        
        // Update de cor
        particle.hue = (particle.hue + intensity * 0.3) % 360;
        
        // Determinar visibilidade baseado na dist√¢ncia
        const distance = Math.sqrt(particle.x * particle.x + particle.y * particle.y + particle.z * particle.z);
        particle.visible = distance < 200;
        particle.lodLevel = distance < 100 ? 0 : distance < 150 ? 1 : 2;
        
        if (particle.visible) {
          this.visibleParticles.push(particle);
        }
      }
    }
    
    return this.visibleParticles;
  }
  
  private getOptimalSkipRate(targetFPS: number): number {
    if (targetFPS < 30) return 3;
    if (targetFPS < 45) return 2;
    return 1;
  }
  
  private getMaxVisibleParticles(targetFPS: number): number {
    if (targetFPS < 30) return 400;
    if (targetFPS < 45) return 600;
    return 800;
  }
  
  optimizeForPerformance(currentFPS: number): void {
    if (currentFPS < 30 && this.particles.length > 400) {
      this.particles = this.particles.slice(0, 400);
      console.log('üîß Part√≠culas reduzidas para 400 devido a FPS baixo');
    } else if (currentFPS < 45 && this.particles.length > 600) {
      this.particles = this.particles.slice(0, 600);
      console.log('üîß Part√≠culas reduzidas para 600 devido a FPS moderado');
    } else if (currentFPS >= 60 && this.particles.length < 800) {
      this.initializeParticles(800);
      console.log('üîß Part√≠culas aumentadas para 800 - Performance boa');
    }
  }
  
  getParticleCount(): number {
    return this.particles.length;
  }
  
  getVisibleParticleCount(): number {
    return this.visibleParticles.length;
  }
}

// === COMPONENTE PRINCIPAL OTIMIZADO ===
export const GenesisCore: React.FC = () => {
  // Refs otimizados
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglCanvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>();
  const lastTimeRef = useRef<number>(0);
  const mouseMoveTimerRef = useRef<number>();
  const fpsHistoryRef = useRef<number[]>([]);
  
  // Sistemas otimizados
  const particleSystemRef = useRef<OptimizedParticleSystem>(new OptimizedParticleSystem(800));
  const webglRendererRef = useRef<UltraFastWebGLRenderer>(new UltraFastWebGLRenderer());
  
  // Estados otimizados
  const [mousePosition, setMousePosition] = useState<MousePosition>({ x: 0.5, y: 0.5 });
  const [emotionalIntensity, setEmotionalIntensity] = useState(0);
  const [currentFPS, setCurrentFPS] = useState(0);
  const [particleCount, setParticleCount] = useState(800);
  const [visibleParticles, setVisibleParticles] = useState(0);
  const [renderMode, setRenderMode] = useState<'webgl' | 'canvas'>('webgl');

  // OTIMIZA√á√ÉO: Throttle de eventos de mouse (30fps)
  const handleMouseMove = useCallback((event: React.MouseEvent) => {
    if (mouseMoveTimerRef.current) return;
    
    mouseMoveTimerRef.current = requestAnimationFrame(() => {
      const rect = canvasRef.current?.getBoundingClientRect();
      if (!rect) return;

      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      
      setMousePosition({ x, y });
      
      const intensity = Math.min(
        Math.sqrt(Math.pow(event.movementX || 0, 2) + Math.pow(event.movementY || 0, 2)) / 50,
        1
      );
      setEmotionalIntensity(intensity);
      
      mouseMoveTimerRef.current = undefined;
    });
  }, []);

  // OTIMIZA√á√ÉO: Loop de renderiza√ß√£o otimizado
  const renderFrame = useCallback((timestamp: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    // C√°lculo de FPS otimizado
    const deltaTime = timestamp - lastTimeRef.current;
    if (deltaTime > 0) {
      const fps = Math.round(1000 / deltaTime);
      fpsHistoryRef.current.push(fps);
      if (fpsHistoryRef.current.length > 10) fpsHistoryRef.current.shift();
      
      const avgFPS = Math.round(fpsHistoryRef.current.reduce((a, b) => a + b, 0) / fpsHistoryRef.current.length);
      setCurrentFPS(avgFPS);
      
      // Otimiza√ß√£o adaptativa baseada em FPS
      particleSystemRef.current.optimizeForPerformance(avgFPS);
      setParticleCount(particleSystemRef.current.getParticleCount());
    }
    lastTimeRef.current = timestamp;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const { width, height } = canvas;
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Renderiza√ß√£o otimizada
    const particles = particleSystemRef.current.updateParticles(emotionalIntensity, currentFPS);
    setVisibleParticles(particles.length);
    
    // Limpar canvas
    ctx.fillStyle = 'rgba(10, 0, 20, 0.2)';
    ctx.fillRect(0, 0, width, height);
    
    // Tentar WebGL primeiro
    let webglSuccess = false;
    if (renderMode === 'webgl' && particles.length > 0) {
      webglSuccess = webglRendererRef.current.renderParticles(
        particles,
        mousePosition,
        emotionalIntensity,
        timestamp
      );
      
      if (!webglSuccess) {
        setRenderMode('canvas');
        console.log('üîÑ Alternando para renderiza√ß√£o Canvas 2D');
      }
    }
    
    // Fallback para Canvas 2D
    if (!webglSuccess) {
      // Renderiza√ß√£o simplificada de part√≠culas
      particles.forEach(particle => {
        if (particle.visible) {
          const perspective = 400;
          const scale = perspective / (perspective + particle.z);
          const screenX = centerX + particle.x * scale;
          const screenY = centerY + particle.y * scale;
          const size = particle.size * scale * (1 + emotionalIntensity * 0.5);
          
          // Desenhar part√≠cula
          ctx.fillStyle = `hsla(${particle.hue}, 70%, 60%, ${0.6 * scale})`;
          ctx.beginPath();
          ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
          ctx.fill();
          
          // Glow effect para part√≠culas pr√≥ximas
          if (particle.lodLevel === 0) {
            ctx.fillStyle = `hsla(${particle.hue}, 50%, 70%, ${0.3 * scale})`;
            ctx.beginPath();
            ctx.arc(screenX, screenY, size * 1.5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
      
      // Desenhar n√∫cleo central
      const coreSize = 40 + Math.sin(timestamp * 0.005) * 10 + emotionalIntensity * 20;
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
      gradient.addColorStop(0, `hsla(200, 80%, 70%, 0.8)`);
      gradient.addColorStop(1, 'hsla(280, 60%, 50%, 0)');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
      ctx.fill();
    }

    animationRef.current = requestAnimationFrame(renderFrame);
  }, [mousePosition, emotionalIntensity, currentFPS, renderMode]);

  // Inicializa√ß√£o WebGL otimizada
  useEffect(() => {
    const webglCanvas = webglCanvasRef.current;
    if (webglCanvas) {
      const success = webglRendererRef.current.initialize(webglCanvas);
      if (!success) {
        setRenderMode('canvas');
        console.log('WebGL n√£o dispon√≠vel, usando Canvas 2D');
      }
    }
  }, []);

  // Configura√ß√£o de resize otimizada
  useEffect(() => {
    const handleResize = () => {
      const canvas = canvasRef.current;
      const webglCanvas = webglCanvasRef.current;
      
      if (canvas) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      
      if (webglCanvas) {
        webglCanvas.width = window.innerWidth;
        webglCanvas.height = window.innerHeight;
      }
    };
    
    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Inicializa√ß√£o do loop de renderiza√ß√£o
  useEffect(() => {
    const animate = (timestamp: number) => {
      renderFrame(timestamp);
      animationRef.current = requestAnimationFrame(animate);
    };
    
    animationRef.current = requestAnimationFrame(animate);
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [renderFrame]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (mouseMoveTimerRef.current) {
        cancelAnimationFrame(mouseMoveTimerRef.current);
      }
      webglRendererRef.current.cleanup();
    };
  }, []);

  // Componente de performance memoizado
  const PerformanceIndicator = memo(() => (
    <div style={{
      position: 'fixed',
      top: '10px',
      right: '10px',
      background: 'rgba(0,0,0,0.8)',
      color: currentFPS >= 45 ? '#00ff00' : currentFPS >= 30 ? '#ffff00' : '#ff0000',
      padding: '8px 12px',
      borderRadius: '8px',
      fontFamily: 'monospace',
      fontSize: '12px',
      zIndex: 1000,
      backdropFilter: 'blur(10px)',
      border: '1px solid rgba(255,255,255,0.1)'
    }}>
      <div>FPS: {currentFPS}</div>
      <div>Part√≠culas: {particleCount}</div>
      <div>Vis√≠veis: {visibleParticles}</div>
      <div>Modo: {renderMode.toUpperCase()}</div>
      <div>Intensidade: {Math.round(emotionalIntensity * 100)}%</div>
    </div>
  ));

  return (
    <div 
      style={{
        width: '100vw',
        height: '100vh',
        margin: 0,
        padding: 0,
        overflow: 'hidden',
        background: 'radial-gradient(ellipse at center, #0a0015 0%, #000000 100%)',
        cursor: 'none'
      }}
      onMouseMove={handleMouseMove}
    >
      {/* Canvas WebGL para part√≠culas */}
      <canvas
        ref={webglCanvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          zIndex: 2,
          pointerEvents: 'none',
          display: renderMode === 'webgl' ? 'block' : 'none'
        }}
      />

      {/* Canvas fallback 2D */}
      <canvas
        ref={canvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          zIndex: 1
        }}
      />

      <PerformanceIndicator />

      {/* Cursor personalizado otimizado */}
      <div style={{
        position: 'fixed',
        left: `${mousePosition.x * 100}%`,
        top: `${mousePosition.y * 100}%`,
        width: '20px',
        height: '20px',
        background: `radial-gradient(circle, 
          hsla(200, 90%, 70%, 0.8), 
          hsla(280, 90%, 60%, 0.3) 60%,
          transparent 70%)`,
        borderRadius: '50%',
        pointerEvents: 'none',
        zIndex: 1000,
        transform: `translate(-50%, -50%) scale(${0.8 + emotionalIntensity * 0.7})`,
        transition: 'transform 0.1s ease-out',
        boxShadow: `0 0 15px hsla(200, 90%, 70%, 0.5)`
      }} />
    </div>
  );
};