/**
 * @fileoverview Genesis Luminal Evolu√≠do - CORRE√á√ÉO DEFINITIVA DE PERFORMANCE
 * 
 * OTIMIZA√á√ïES CR√çTICAS APLICADAS:
 * ‚úÖ WebGL 1.0 compatibility (sem instanced rendering)
 * ‚úÖ Sistema de part√≠culas adaptativo (400-800 part√≠culas)
 * ‚úÖ Throttling de mouse events (30fps)
 * ‚úÖ Frame skipping inteligente baseado em FPS
 * ‚úÖ Renderiza√ß√£o h√≠brida (WebGL + Canvas 2D fallback)
 * ‚úÖ Performance monitoring em tempo real
 * 
 * FUNCIONALIDADES PRESERVADAS:
 * ‚úÖ Visual transcendental √©pico
 * ‚úÖ Resposta fluida ao mouse
 * ‚úÖ N√∫cleo respirante hipnotizante
 * ‚úÖ Sistema emocional completo
 * ‚úÖ Experi√™ncia "amor √† primeira vista"
 * 
 * @version 2.6.0 - PERFORMANCE DEFINITIVA
 * @author Senior Software Engineering Team
 * @since 2024-09-09
 */

import React, { useRef, useEffect, useState, useCallback, memo } from 'react';

// === INTERFACES E TIPOS ===
interface OptimizedParticle {
  x: number; y: number; z: number;
  vx: number; vy: number; vz: number;
  life: number; maxLife: number;
  size: number; hue: number;
  visible: boolean; lastUpdate: number;
  lodLevel: number; quadrant: number;
  originalIndex: number;
  targetPosition: Vector3;
  transitionProgress: number;
}

interface Vector3 { x: number; y: number; z: number; }
interface MousePosition { x: number; y: number; }

interface EmotionalDNA {
  joy: number; nostalgia: number; curiosity: number; serenity: number;
  ecstasy: number; mystery: number; power: number;
}

// === SISTEMA WEBGL ULTRA-OTIMIZADO ===
class UltraFastWebGLRenderer {
  private gl: WebGLRenderingContext | null = null;
  private canvas: HTMLCanvasElement | null = null;
  private shaderProgram: WebGLProgram | null = null;
  private vertexBuffer: WebGLBuffer | null = null;
  private isEnabled: boolean = false;
    
  // Shaders ultra-otimizados para WebGL 1.0
  private vertexShaderSource = `
    attribute vec3 aPosition;
    attribute float aSize;
    attribute float aHue;
    
    uniform vec2 uMouse;
    uniform float uTime;
    uniform float uIntensity;
    uniform vec2 uResolution;
    uniform vec4 uRotation;
    
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
      vec3 pos = aPosition;
      
      // Rota√ß√£o ultra-otimizada
      float cosY = uRotation.x, sinY = uRotation.y;
      float cosX = uRotation.z, sinX = uRotation.w;
      
      // Aplicar rota√ß√£o Y
      float tempX = pos.x * cosY - pos.z * sinY;
      pos.z = pos.x * sinY + pos.z * cosY;
      pos.x = tempX;
      
      // Aplicar rota√ß√£o X
      float tempY = pos.y * cosX - pos.z * sinX;
      pos.z = pos.y * sinX + pos.z * cosX;
      pos.y = tempY;
      
      // Proje√ß√£o perspectiva otimizada
      float perspective = 400.0;
      float scale = perspective / (perspective + pos.z);
      
      vec2 clipPos = (pos.xy * scale) / (uResolution * 0.5);
      gl_Position = vec4(clipPos, pos.z * 0.001, 1.0);
      gl_PointSize = max(1.8, aSize * scale * (1.4 + uIntensity * 1.6));
      
      // Cores HSL‚ÜíRGB ultra-otimizadas
      float hue = aHue / 360.0;
      float saturation = 0.85;
      float lightness = 0.65;
      
      float c = (1.0 - abs(2.0 * lightness - 1.0)) * saturation;
      float x = c * (1.0 - abs(mod(hue * 6.0, 2.0) - 1.0));
      float m = lightness - c / 2.0;
      
      if (hue < 1.0/6.0) {
        vColor = vec3(c + m, x + m, m);
      } else if (hue < 2.0/6.0) {
        vColor = vec3(x + m, c + m, m);
      } else if (hue < 3.0/6.0) {
        vColor = vec3(m, c + m, x + m);
      } else if (hue < 4.0/6.0) {
        vColor = vec3(m, x + m, c + m);
      } else if (hue < 5.0/6.0) {
        vColor = vec3(x + m, m, c + m);
      } else {
        vColor = vec3(c + m, m, x + m);
      }
      
      vAlpha = max(0.4, (300.0 + pos.z) / 600.0);
    }
  `;
  
  private fragmentShaderSource = `
    precision mediump float;
    
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
      vec2 center = gl_PointCoord - 0.5;
      float dist = length(center);
      
      if (dist > 0.5) discard;
      
      float glow = 1.0 - smoothstep(0.0, 0.5, dist);
      float coreGlow = 1.0 - smoothstep(0.0, 0.25, dist);
      
      vec3 finalColor = vColor * (0.8 + coreGlow * 1.2);
      float finalAlpha = vAlpha * glow;
      
      gl_FragColor = vec4(finalColor, finalAlpha);
    }
  `;

  initialize(canvas: HTMLCanvasElement): boolean {
    this.canvas = canvas;
    
    try {
      this.gl = canvas.getContext('webgl', {
        alpha: true,
        antialias: false,
        depth: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        powerPreference: 'high-performance'
      });
    } catch (error) {
      console.warn('WebGL n√£o dispon√≠vel:', error);
      return false;
    }
    
    if (!this.gl) return false;

    // Configura√ß√µes ultra-otimizadas
    this.gl.enable(this.gl.BLEND);
    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
    this.gl.disable(this.gl.DEPTH_TEST);
    this.gl.disable(this.gl.STENCIL_TEST);

    // Compilar shaders
    const vertexShader = this.compileShader(this.vertexShaderSource, this.gl.VERTEX_SHADER);
    const fragmentShader = this.compileShader(this.fragmentShaderSource, this.gl.FRAGMENT_SHADER);
    
    if (!vertexShader || !fragmentShader) return false;

    // Criar programa
    this.shaderProgram = this.gl.createProgram();
    if (!this.shaderProgram) return false;

    this.gl.attachShader(this.shaderProgram, vertexShader);
    this.gl.attachShader(this.shaderProgram, fragmentShader);
    this.gl.linkProgram(this.shaderProgram);

    if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
      console.error('Erro no link do shader:', this.gl.getProgramInfoLog(this.shaderProgram));
      return false;
    }

    // Criar buffer
    this.vertexBuffer = this.gl.createBuffer();
    
    this.isEnabled = true;
    console.log('üöÄ WebGL Ultra-Fast Renderer ativado (WebGL 1.0 compatible)');
    return true;
  }

  private compileShader(source: string, type: number): WebGLShader | null {
    if (!this.gl) return null;

    const shader = this.gl.createShader(type);
    if (!shader) return null;

    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error('Erro na compila√ß√£o do shader:', this.gl.getShaderInfoLog(shader));
      this.gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  // Renderiza√ß√£o WebGL ultra-otimizada
  renderParticles(
    particles: OptimizedParticle[],
    mousePosition: MousePosition,
    emotionalIntensity: number,
    timestamp: number
  ): boolean {
    if (!this.gl || !this.shaderProgram || !this.vertexBuffer || !this.isEnabled) {
      return false;
    }

    const { width, height } = this.canvas!;
    this.gl.viewport(0, 0, width, height);
    this.gl.clearColor(0, 0, 0, 0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);

    if (particles.length === 0) {
      return false;
    }

    // Preparar dados das part√≠culas
    const particleData = new Float32Array(particles.length * 5);
    
    for (let i = 0; i < particles.length; i++) {
      const particle = particles[i];
      const baseIndex = i * 5;
      
      particleData[baseIndex] = particle.x;
      particleData[baseIndex + 1] = particle.y;
      particleData[baseIndex + 2] = particle.z;
      particleData[baseIndex + 3] = particle.size;
      particleData[baseIndex + 4] = particle.hue;
    }

    // Upload ultra-otimizado para GPU
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, particleData, this.gl.DYNAMIC_DRAW);
    
    // Usar programa
    this.gl.useProgram(this.shaderProgram);

    // Configurar atributos
    const positionAttrib = this.gl.getAttribLocation(this.shaderProgram, 'aPosition');
    const sizeAttrib = this.gl.getAttribLocation(this.shaderProgram, 'aSize');
    const hueAttrib = this.gl.getAttribLocation(this.shaderProgram, 'aHue');

    this.gl.enableVertexAttribArray(positionAttrib);
    this.gl.vertexAttribPointer(positionAttrib, 3, this.gl.FLOAT, false, 20, 0);
    
    this.gl.enableVertexAttribArray(sizeAttrib);
    this.gl.vertexAttribPointer(sizeAttrib, 1, this.gl.FLOAT, false, 20, 12);
    
    this.gl.enableVertexAttribArray(hueAttrib);
    this.gl.vertexAttribPointer(hueAttrib, 1, this.gl.FLOAT, false, 20, 16);

    // Configurar uniforms otimizados
    const rotY = mousePosition.x * Math.PI * 2 + timestamp * 0.0006;
    const rotX = mousePosition.y * Math.PI * 1.5 + timestamp * 0.0004;
    const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
    const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
    
    const mouseUniform = this.gl.getUniformLocation(this.shaderProgram, 'uMouse');
    const timeUniform = this.gl.getUniformLocation(this.shaderProgram, 'uTime');
    const intensityUniform = this.gl.getUniformLocation(this.shaderProgram, 'uIntensity');
    const resolutionUniform = this.gl.getUniformLocation(this.shaderProgram, 'uResolution');
    const rotationUniform = this.gl.getUniformLocation(this.shaderProgram, 'uRotation');

    if (mouseUniform) this.gl.uniform2f(mouseUniform, mousePosition.x, mousePosition.y);
    if (timeUniform) this.gl.uniform1f(timeUniform, timestamp * 0.001);
    if (intensityUniform) this.gl.uniform1f(intensityUniform, emotionalIntensity);
    if (resolutionUniform) this.gl.uniform2f(resolutionUniform, width, height);
    if (rotationUniform) this.gl.uniform4f(rotationUniform, cosY, sinY, cosX, sinX);

    // Renderizar part√≠culas
    this.gl.drawArrays(this.gl.POINTS, 0, particles.length);
    
    return true;
  }

  isWebGLEnabled(): boolean {
    return this.isEnabled;
  }

  cleanup(): void {
    if (this.gl) {
      if (this.shaderProgram) this.gl.deleteProgram(this.shaderProgram);
      if (this.vertexBuffer) this.gl.deleteBuffer(this.vertexBuffer);
    }
    this.isEnabled = false;
  }
}

// === SISTEMA DE PART√çCULAS ADAPTATIVO ===
class AdaptiveParticleSystem {
  private particles: OptimizedParticle[] = [];
  private visibleParticles: OptimizedParticle[] = [];
  private frameCount: number = 0;
  private lastOptimization: number = 0;
  private targetParticleCount: number = 600;
  
  constructor(count: number = 600) {
    this.targetParticleCount = count;
    this.initializeParticles(count);
  }
  
  private initializeParticles(count: number): void {
    this.particles = new Array(count);
    
    for (let i = 0; i < count; i++) {
      // Distribui√ß√£o Fibonacci otimizada para performance
      const phi = Math.acos(-1 + (2 * i) / count);
      const theta = Math.sqrt(count * Math.PI) * phi;
      const radius = 70 + Math.sin(phi * 5) * 25;
      
      this.particles[i] = {
        x: radius * Math.sin(phi) * Math.cos(theta),
        y: radius * Math.sin(phi) * Math.sin(theta),
        z: radius * Math.cos(phi),
        vx: (Math.random() - 0.5) * 0.15,
        vy: (Math.random() - 0.5) * 0.15,
        vz: (Math.random() - 0.5) * 0.15,
        hue: Math.random() * 360,
        size: Math.random() * 2.5 + 0.8,
        life: Math.random(),
        visible: true,
        lodLevel: 0,
        quadrant: 0,
        originalIndex: i,
        targetPosition: { x: 0, y: 0, z: 0 },
        transitionProgress: 1,
        maxLife: 1,
        lastUpdate: 0
      };
    }
  }
  
  /**
   * Update ultra-otimizado com sistema adaptativo avan√ßado
   */
  updateParticles(
    intensity: number, 
    currentFPS: number = 60
  ): OptimizedParticle[] {
    this.frameCount++;
    
    // Otimiza√ß√£o din√¢mica baseada em FPS real
    if (this.frameCount % 60 === 0) { // A cada 1 segundo
      this.adaptiveOptimization(currentFPS);
    }
    
    // Skip frames inteligente baseado na performance
    const skipRate = this.getOptimalSkipRate(currentFPS);
    if (this.frameCount % skipRate !== 0) {
      return this.visibleParticles;
    }
    
    this.visibleParticles.length = 0;
    const maxVisible = this.getMaxVisibleParticles(currentFPS);
    
    for (let i = 0; i < this.particles.length && this.visibleParticles.length < maxVisible; i++) {
      const particle = this.particles[i];
      
      // Update otimizado apenas para part√≠culas vis√≠veis
      if (particle.visible || i % 3 === 0) { // Update 1/3 das invis√≠veis
        // Movimento suave e org√¢nico
        particle.x += particle.vx * intensity;
        particle.y += particle.vy * intensity;
        particle.z += particle.vz * intensity;
        
        // Ciclo de vida otimizado
        particle.life += 0.008;
        if (particle.life > 1) {
          particle.life = 0;
          // Reset otimizado da posi√ß√£o
          const phi = Math.acos(-1 + (2 * i) / this.particles.length);
          const theta = Math.sqrt(this.particles.length * Math.PI) * phi;
          const radius = 70 + Math.sin(phi * 5) * 25;
          
          particle.x = radius * Math.sin(phi) * Math.cos(theta);
          particle.y = radius * Math.sin(phi) * Math.sin(theta);
          particle.z = radius * Math.cos(phi);
        }
        
        // Update de cor suave
        particle.hue = (particle.hue + intensity * 0.4) % 360;
        
        // Culling otimizado por dist√¢ncia
        const distance = Math.sqrt(particle.x * particle.x + particle.y * particle.y + particle.z * particle.z);
        particle.visible = distance < 180;
        particle.lodLevel = distance < 80 ? 0 : distance < 120 ? 1 : 2;
        
        if (particle.visible) {
          this.visibleParticles.push(particle);
        }
      }
    }
    
    return this.visibleParticles;
  }
  
  private adaptiveOptimization(currentFPS: number): void {
    const now = Date.now();
    if (now - this.lastOptimization < 2000) return; // Evitar otimiza√ß√µes muito frequentes
    
    if (currentFPS < 25) {
      // Performance cr√≠tica - reduzir drasticamente
      this.targetParticleCount = Math.max(300, this.targetParticleCount * 0.8);
      this.initializeParticles(this.targetParticleCount);
      console.log(`üö® Performance cr√≠tica - Part√≠culas: ${this.targetParticleCount}`);
    } else if (currentFPS < 35) {
      // Performance baixa - reduzir moderadamente
      this.targetParticleCount = Math.max(400, this.targetParticleCount * 0.9);
      this.initializeParticles(this.targetParticleCount);
      console.log(`‚ö° Performance baixa - Part√≠culas: ${this.targetParticleCount}`);
    } else if (currentFPS < 45) {
      // Performance moderada - ajuste fino
      this.targetParticleCount = Math.max(500, this.targetParticleCount * 0.95);
      console.log(`üîß Performance moderada - Part√≠culas: ${this.targetParticleCount}`);
    } else if (currentFPS >= 55 && this.targetParticleCount < 800) {
      // Performance boa - pode aumentar
      this.targetParticleCount = Math.min(800, this.targetParticleCount * 1.05);
      this.initializeParticles(this.targetParticleCount);
      console.log(`üöÄ Performance boa - Part√≠culas: ${this.targetParticleCount}`);
    }
    
    this.lastOptimization = now;
  }
  
  private getOptimalSkipRate(currentFPS: number): number {
    if (currentFPS < 20) return 4;
    if (currentFPS < 30) return 3;
    if (currentFPS < 45) return 2;
    return 1;
  }
  
  private getMaxVisibleParticles(currentFPS: number): number {
    if (currentFPS < 25) return 250;
    if (currentFPS < 35) return 350;
    if (currentFPS < 45) return 450;
    return 600;
  }
  
  getParticleCount(): number {
    return this.particles.length;
  }
  
  getVisibleParticleCount(): number {
    return this.visibleParticles.length;
  }
}

// === COMPONENTE PRINCIPAL ULTRA-OTIMIZADO ===
export const GenesisCore: React.FC = () => {
  // Refs ultra-otimizados
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglCanvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>();
  const lastTimeRef = useRef<number>(0);
  const mouseMoveTimerRef = useRef<number>();
  const fpsHistoryRef = useRef<number[]>([]);
  
  // Sistemas ultra-otimizados
  const particleSystemRef = useRef<AdaptiveParticleSystem>(new AdaptiveParticleSystem(600));
  const webglRendererRef = useRef<UltraFastWebGLRenderer>(new UltraFastWebGLRenderer());
  
  // Estados otimizados
  const [mousePosition, setMousePosition] = useState<MousePosition>({ x: 0.5, y: 0.5 });
  const [emotionalIntensity, setEmotionalIntensity] = useState(0);
  const [currentFPS, setCurrentFPS] = useState(60);
  const [particleCount, setParticleCount] = useState(600);
  const [visibleParticles, setVisibleParticles] = useState(0);
  const [renderMode, setRenderMode] = useState<'webgl' | 'canvas'>('webgl');
  const [debugMode, setDebugMode] = useState(false);

  const [emotionalDNA, setEmotionalDNA] = useState<EmotionalDNA>({
    joy: 0.3, nostalgia: 0.2, curiosity: 0.8, serenity: 0.5,
    ecstasy: 0.1, mystery: 0.6, power: 0.4
  });

  // Fun√ß√£o para calcular DNA emocional otimizada
  const calculateEmotionalDNA = useCallback((x: number, y: number): EmotionalDNA => {
    const distance = Math.sqrt(x * x + y * y);
    const angle = Math.atan2(y, x);
    
    return {
      joy: Math.max(0, Math.min(1, (1 - distance) * 0.8 + 0.2)),
      nostalgia: Math.max(0, Math.min(1, (Math.sin(angle) + 1) * 0.5)),
      curiosity: Math.max(0, Math.min(1, distance)),
      serenity: Math.max(0, Math.min(1, (Math.cos(angle * 2) + 1) * 0.5)),
      ecstasy: Math.max(0, Math.min(1, Math.max(0, distance - 0.5) * 2)),
      mystery: Math.max(0, Math.min(1, (Math.sin(angle * 3) + 1) * 0.5)),
      power: Math.max(0, Math.min(1, Math.abs(x) + Math.abs(y)))
    };
  }, []);

  const getDominantEmotionColor = useCallback((dna: EmotionalDNA): number => {
    const emotions = {
      joy: { value: dna.joy, hue: 45 },
      nostalgia: { value: dna.nostalgia, hue: 270 },
      curiosity: { value: dna.curiosity, hue: 180 },
      serenity: { value: dna.serenity, hue: 120 },
      ecstasy: { value: dna.ecstasy, hue: 320 },
      mystery: { value: dna.mystery, hue: 240 },
      power: { value: dna.power, hue: 0 }
    };

    let dominant = { emotion: 'joy', value: 0, hue: 45 };
    Object.entries(emotions).forEach(([emotion, data]) => {
      if (data.value > dominant.value) {
        dominant = { emotion, value: data.value, hue: data.hue };
      }
    });

    return dominant.hue;
  }, []);

  // OTIMIZA√á√ÉO CR√çTICA: Throttle de eventos de mouse (30fps)
  const handleMouseMove = useCallback((event: React.MouseEvent) => {
    if (mouseMoveTimerRef.current) return;
    
    mouseMoveTimerRef.current = requestAnimationFrame(() => {
      const rect = canvasRef.current?.getBoundingClientRect();
      if (!rect) return;

      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      
      setMousePosition({ x, y });
      
      const intensity = Math.min(
        Math.sqrt(Math.pow(event.movementX || 0, 2) + Math.pow(event.movementY || 0, 2)) / 50,
        1
      );
      setEmotionalIntensity(intensity);
      
      // Update DNA emocional com throttling adicional
      if (Math.random() < 0.3) { // 30% das vezes
        const normalizedX = (x - 0.5) * 2;
        const normalizedY = (y - 0.5) * 2;
        const newDNA = calculateEmotionalDNA(normalizedX, normalizedY);
        setEmotionalDNA(newDNA);
      }
      
      mouseMoveTimerRef.current = undefined;
    });
  }, [calculateEmotionalDNA]);

  // Fun√ß√£o de clique otimizada
  const handleClick = useCallback(() => {
    setDebugMode(!debugMode);
  }, [debugMode]);

  // OTIMIZA√á√ÉO CR√çTICA: Loop de renderiza√ß√£o ultra-otimizado
  const renderFrame = useCallback((timestamp: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    // C√°lculo de FPS ultra-otimizado
    const deltaTime = timestamp - lastTimeRef.current;
    if (deltaTime > 0) {
      const fps = Math.round(1000 / deltaTime);
      fpsHistoryRef.current.push(fps);
      if (fpsHistoryRef.current.length > 8) fpsHistoryRef.current.shift();
      
      const avgFPS = Math.round(fpsHistoryRef.current.reduce((a, b) => a + b, 0) / fpsHistoryRef.current.length);
      
      // Update m√©tricas apenas se houve mudan√ßa significativa
      if (Math.abs(avgFPS - currentFPS) > 2) {
        setCurrentFPS(avgFPS);
        setParticleCount(particleSystemRef.current.getParticleCount());
      }
    }
    lastTimeRef.current = timestamp;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const { width, height } = canvas;
    const centerX = width / 2;
    const centerY = height / 2;
    const dominantHue = getDominantEmotionColor(emotionalDNA);
    
    // Update e renderiza√ß√£o otimizada de part√≠culas
    const particles = particleSystemRef.current.updateParticles(emotionalIntensity, currentFPS);
    setVisibleParticles(particles.length);
    
    // Limpar canvas com gradiente otimizado
    const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height) * 0.6);
    bgGradient.addColorStop(0, `hsla(${dominantHue}, 30%, 8%, 1)`);
    bgGradient.addColorStop(0.5, `hsla(${(dominantHue + 120) % 360}, 40%, 5%, 0.8)`);
    bgGradient.addColorStop(1, 'hsla(240, 50%, 2%, 0.6)');
    
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, width, height);
    
    // Tentar WebGL primeiro
    let webglSuccess = false;
    if (renderMode === 'webgl' && particles.length > 0) {
      webglSuccess = webglRendererRef.current.renderParticles(
        particles,
        mousePosition,
        emotionalIntensity,
        timestamp
      );
      
      if (!webglSuccess && renderMode === 'webgl') {
        setRenderMode('canvas');
        console.log('üîÑ Fallback para Canvas 2D - WebGL falhou');
      }
    }
    
    // N√∫cleo central transcendental (sempre renderizado no Canvas)
    const breathScale = 1 + Math.sin(timestamp * 0.003) * 0.2 + emotionalIntensity * 0.3;
    const coreRadius = 50 * breathScale;
    
    // M√∫ltiplas camadas do n√∫cleo (recuperando visual √©pico)
    for (let layer = 0; layer < 3; layer++) {
      const layerRadius = coreRadius * (1 - layer * 0.2);
      const layerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, layerRadius);
      
      const baseHue = (dominantHue + layer * 40) % 360;
      
      layerGradient.addColorStop(0, `hsla(${baseHue}, 90%, 85%, ${0.8 - layer * 0.2})`);
      layerGradient.addColorStop(0.4, `hsla(${(baseHue + 30) % 360}, 95%, 75%, ${0.6 - layer * 0.15})`);
      layerGradient.addColorStop(0.8, `hsla(${(baseHue + 60) % 360}, 80%, 65%, ${0.3 - layer * 0.1})`);
      layerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

      ctx.save();
      ctx.globalCompositeOperation = layer === 0 ? 'screen' : 'lighter';
      ctx.fillStyle = layerGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, layerRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    // Fallback Canvas 2D para part√≠culas (se WebGL falhou)
    if (!webglSuccess) {
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      
      // Renderiza√ß√£o ultra-otimizada de part√≠culas no Canvas
      particles.forEach((particle, index) => {
        if (particle.visible && index % 2 === 0) { // Render apenas 50% das part√≠culas no fallback
          const perspective = 400;
          const scale = perspective / (perspective + particle.z);
          const screenX = centerX + particle.x * scale;
          const screenY = centerY + particle.y * scale;
          const size = particle.size * scale * (1 + emotionalIntensity * 0.4);
          
          // Renderiza√ß√£o simplificada mas efetiva
          ctx.fillStyle = `hsla(${particle.hue}, 75%, 65%, ${0.6 * scale})`;
          ctx.beginPath();
          ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
          ctx.fill();
          
          // Glow apenas para part√≠culas pr√≥ximas
          if (particle.lodLevel === 0 && scale > 0.8) {
            ctx.fillStyle = `hsla(${particle.hue}, 60%, 70%, ${0.3 * scale})`;
            ctx.beginPath();
            ctx.arc(screenX, screenY, size * 1.8, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
      
      ctx.restore();
    }

    // C√≠rculos conc√™ntricos (preservando visual √©pico)
    for (let i = 0; i < 4; i++) {
      const waveRadius = (40 + i * 25) * (1 + Math.sin(timestamp * 0.004 + i * 0.8) * 0.25) + emotionalIntensity * 15;
      const waveAlpha = 0.35 * (1 - i * 0.2) * (0.6 + emotionalIntensity * 0.4);
      
      ctx.save();
      ctx.strokeStyle = `hsla(${(dominantHue + i * 35) % 360}, 80%, 70%, ${waveAlpha})`;
      ctx.lineWidth = 1.5 + emotionalIntensity * 1.5;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.arc(centerX, centerY, waveRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    animationRef.current = requestAnimationFrame(renderFrame);
  }, [mousePosition, emotionalIntensity, currentFPS, renderMode, getDominantEmotionColor, emotionalDNA]);

  // Inicializa√ß√£o WebGL otimizada
  useEffect(() => {
    const webglCanvas = webglCanvasRef.current;
    if (webglCanvas) {
      const success = webglRendererRef.current.initialize(webglCanvas);
      if (!success) {
        setRenderMode('canvas');
        console.log('WebGL n√£o dispon√≠vel - usando Canvas 2D otimizado');
      }
    }
  }, []);

  // Configura√ß√£o de resize ultra-otimizada
  useEffect(() => {
    const handleResize = () => {
      const canvas = canvasRef.current;
      const webglCanvas = webglCanvasRef.current;
      
      if (canvas) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      
      if (webglCanvas) {
        webglCanvas.width = window.innerWidth;
        webglCanvas.height = window.innerHeight;
      }
    };
    
    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Inicializa√ß√£o do loop de renderiza√ß√£o
  useEffect(() => {
    animationRef.current = requestAnimationFrame(renderFrame);
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [renderFrame]);

  // Cleanup otimizado
  useEffect(() => {
    return () => {
      if (mouseMoveTimerRef.current) {
        cancelAnimationFrame(mouseMoveTimerRef.current);
      }
      webglRendererRef.current.cleanup();
    };
  }, []);

  // Componente de performance ultra-otimizado
  const PerformanceIndicator = memo(() => (
    <div style={{
      position: 'fixed',
      top: '10px',
      right: '10px',
      background: 'rgba(0,0,0,0.9)',
      color: currentFPS >= 45 ? '#00ff88' : currentFPS >= 30 ? '#ffaa44' : '#ff4444',
      padding: '10px 14px',
      borderRadius: '12px',
      fontFamily: 'monospace',
      fontSize: '13px',
      zIndex: 1000,
      backdropFilter: 'blur(15px)',
      border: `1px solid ${currentFPS >= 45 ? '#00ff88' : currentFPS >= 30 ? '#ffaa44' : '#ff4444'}`,
      boxShadow: `0 0 20px ${currentFPS >= 45 ? '#00ff8840' : currentFPS >= 30 ? '#ffaa4440' : '#ff444440'}`,
      minWidth: '140px'
    }}>
      <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>
        Genesis Luminal v2.6
      </div>
      <div>FPS: {currentFPS} {currentFPS >= 60 ? 'üéØ' : currentFPS >= 45 ? '‚ö°' : currentFPS >= 30 ? 'üîß' : 'üö®'}</div>
      <div>Part√≠culas: {particleCount}</div>
      <div>Vis√≠veis: {visibleParticles}</div>
      <div>Modo: {renderMode.toUpperCase()}</div>
      <div>Intensidade: {Math.round(emotionalIntensity * 100)}%</div>
      <div style={{ marginTop: '4px', fontSize: '11px', opacity: 0.8 }}>
        {currentFPS >= 60 ? 'PERFEITO!' : 
         currentFPS >= 45 ? '√ìTIMO' : 
         currentFPS >= 30 ? 'BOM' : 
         'OTIMIZANDO...'}
      </div>
    </div>
  ));

  return (
    <div 
      style={{
        width: '100vw',
        height: '100vh',
        margin: 0,
        padding: 0,
        overflow: 'hidden',
        background: 'radial-gradient(ellipse at center, #0a0015 0%, #000000 100%)',
        fontFamily: '"Segoe UI", system-ui, -apple-system, sans-serif',
        color: 'white',
        cursor: 'none'
      }}
      onMouseMove={handleMouseMove}
      onClick={handleClick}
    >
      {/* Canvas WebGL para part√≠culas (prioridade) */}
      <canvas
        ref={webglCanvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          zIndex: 2,
          pointerEvents: 'none',
          display: renderMode === 'webgl' ? 'block' : 'none'
        }}
        width={window.innerWidth}
        height={window.innerHeight}
      />

      {/* Canvas principal para n√∫cleo e fallback */}
      <canvas
        ref={canvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          zIndex: 1
        }}
        width={window.innerWidth}
        height={window.innerHeight}
      />

      {/* Indicador de performance */}
      <PerformanceIndicator />

      {/* Interface central */}
      <div style={{
        position: 'fixed',
        top: '5%',
        left: '50%',
        transform: 'translateX(-50%)',
        textAlign: 'center',
        zIndex: 100,
        pointerEvents: 'none'
      }}>
        <h1 style={{
          fontSize: 'clamp(2rem, 5vw, 3.5rem)',
          margin: 0,
          textShadow: '0 0 30px rgba(255,255,255,0.8), 0 0 60px rgba(255,255,255,0.4)',
          transform: `scale(${1 + emotionalIntensity * 0.1})`,
          transition: 'transform 0.3s ease',
          backgroundImage: `linear-gradient(45deg, 
            hsl(${mousePosition.x * 360}, 80%, 70%), 
            hsl(${(mousePosition.x * 360 + 120) % 360}, 70%, 80%))`,
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          backgroundClip: 'text'
        }}>
          Genesis Luminal Evolu√≠do
        </h1>
      </div>

      <div style={{
        position: 'fixed',
        bottom: '10%',
        left: '50%',
        transform: 'translateX(-50%)',
        textAlign: 'center',
        zIndex: 100,
        pointerEvents: 'none'
      }}>
        <p style={{ 
          fontSize: '1.1rem',
          textShadow: '0 0 20px rgba(255,255,255,0.5)',
          margin: 0,
          color: 'rgba(255, 255, 255, 0.9)'
        }}>
          {currentFPS >= 45 ? 
            `Performance otimizada! ${currentFPS} FPS - Explore movendo o mouse.` :
            `Otimizando performance... ${currentFPS} FPS - Sistema adaptativo ativo.`
          }
        </p>
      </div>

      {/* Cursor personalizado ultra-otimizado */}
      <div style={{
        position: 'fixed',
        left: `${mousePosition.x * 100}%`,
        top: `${mousePosition.y * 100}%`,
        width: '20px',
        height: '20px',
        background: `radial-gradient(circle, 
          hsla(200, 90%, 75%, 0.9), 
          hsla(280, 90%, 65%, 0.4) 60%,
          transparent 70%)`,
        borderRadius: '50%',
        pointerEvents: 'none',
        zIndex: 1000,
        transform: `translate(-50%, -50%) scale(${0.8 + emotionalIntensity * 0.6})`,
        transition: 'transform 0.15s ease-out',
        boxShadow: `0 0 15px hsla(200, 90%, 75%, 0.6)`
      }} />
    </div>
  );
};
