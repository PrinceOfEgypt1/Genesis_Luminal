import type { Request, Response, NextFunction } from 'express';
import { RateLimiterMemory } from 'rate-limiter-flexible';

const WINDOW_MS = Number(process.env.RATE_LIMIT_WINDOW_MS ?? 15 * 60_000);
const MAX_POINTS = Number(process.env.RATE_LIMIT_MAX ?? 100);

// rate-limiter-flexible trabalha com segundos
const durationSec = Number.isFinite(WINDOW_MS / 1000) ? Math.max(1, Math.floor(WINDOW_MS / 1000)) : 900;

const limiter = new RateLimiterMemory({
  points: Number.isFinite(MAX_POINTS) ? MAX_POINTS : 100,
  duration: durationSec,
  blockDuration: durationSec,
});

function resolveClientKey(req: Request): string {
  const xf = req.headers['x-forwarded-for'];
  const xfFirst =
    (Array.isArray(xf) ? xf[0] : (typeof xf === 'string' ? xf.split(',')[0] : undefined))?.trim();
  return (
    req.ip ??
    xfFirst ??
    (req.socket as any)?.remoteAddress ??
    'unknown'
  ).toString();
}

export async function rateLimit(req: Request, res: Response, next: NextFunction) {
  const key = resolveClientKey(req);
  try {
    await limiter.consume(key);
    return next();
  } catch (rejRes) {
    const msBeforeNext =
      (rejRes as { msBeforeNext?: number } | undefined)?.msBeforeNext ?? 60_000;
    const retryAfter = Math.max(1, Math.round(msBeforeNext / 1000));
    res.setHeader('Retry-After', String(retryAfter));
    return res.status(429).json({ message: 'Too Many Requests', retryAfter });
  }
}

export default rateLimit;
